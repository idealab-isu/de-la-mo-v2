# Copyright 2016-2018 Iowa State University Research Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import os
import os.path
import sys
import time
import __main__ as main
import traceback

from collections import OrderedDict

## This imports so it fails here if stuff is not available
#import delamo.CADwrap


try:
    import redbaron
    from . import processor
    pass
except ImportError:
    sys.stderr.write("RedBaron and/or delamo.processor not available; is RedBaron installed?\n\n(Only limited delamo_process functionality is available without RedBaron)\n\nTraceback follows\n---------------------------\n\n")
    traceback.print_exc()

    redbaron=None
    # dummy fallthrough class to replace processor module
    # Should have all attributes that are referenced in
    # processes =  dictionary (below)
    class processor(object):
        original_to_predamage_tree=None
        predamage_to_damage_tree=None
        predamage_preclean=None
        run_damage_script=None
        pass
    pass


# A Note on files and directories:
#  * delamo_process may be run from any directory, but
#    the original python script is only intended to be
#    be run from the directory in which it is located.
#  * Modified versions of the original python script are
#    located in the outputdir, but these are run from
#    the directory of the original Python script
#  * The generated Abaqus code is run from the outputdir.
#    This means that any filenames passed to Abaqus need
#    to be relative to the outputdir
#  * "Basename" refers to the filename of the original,
#    human-written script, but with the .py removed
#  * "basename_withpath" refers to the path from whatever
#    directory we were run from to the original human-written
#    script, but with the .py removed.
#  * output_directory (generated by output_dir()) refers to the
#    path from whatever directory we were run from to the
#    output directory 

# DEFECT_INSERTION Process phases:
# ORIGINAL  -- human-written script
# PREDAMAGE -- unwrapped version of human-written script 
# DAMAGED -- With damage outlines attached. 

processes = {
    None: (("ORIGINAL",None,{}),),
    "DEFECT_INSERTION": (("ORIGINAL",None,{}),
                         ("PREDAMAGE",processor.original_to_predamage_tree,{"preclean_method": processor.predamage_preclean } ), # Routines specified here are called with five parameters: basename, basename_withpath, output_directory, phase, and rb_tree, which is the RedBaron tree of the prior DELAMO_SCRIPT==True (default) phase
                         ("APPLY_DAMAGE",processor.run_damage_script,{"DELAMO_SCRIPT": False}),
                         ("DAMAGED",processor.predamage_to_damage_tree,{})),
}

output_filenames_params = [ "basename" ]
if redbaron is not None:
    output_filenames_default_params = OrderedDict([
        ("phase", redbaron.NameNode.from_fst({"type":"name","value":"None"})),
        ("process", redbaron.NameNode.from_fst({"type":"name","value":"None"})),
        ("nodircheck", redbaron.NameNode.from_fst({"type":"name","value":"False"})),
        ("apply_damage_script", redbaron.NameNode.from_fst({"type":"name","value":"None"})),
    ])
else:
    output_filenames_default_params = None
    pass

def output_dir(basename_withpath,nodircheck=False):
    output_directory=basename_withpath+"_output"
    if not nodircheck:
        if not os.path.exists(output_directory):
            os.mkdir(output_directory)
            pass
        pass
    return output_directory
        

# *** NOTE: If parameters to output_filenames() are changed
# NOTE do not change parameters of output_filename()
# without changing output_filenames_params and output_filenames_default_params, above.
def output_filenames(basename,phase=None,process=None,nodircheck=False,apply_damage_script=None):
    """ Returns (script_to_generate,cad_file_path_from_script,layer_boundary_template)
    given an original script basename, specified phase (or None), 
    and specified process. From an original script, phase should be 
    "ORIGINAL", and process should usually be None or "DEFECT_INSERTION".
    nodircheck parameter is for internal use only. 

    Output_filenames is intended to be called from the delamo script, 
    which runs in the same directory as the original human-written 
    script, so basename and basename_withpath are equivalent. 

    If this is called in other contexts, include the path in basename. 
"""
    if phase is None:
        raise ValueError("phase must be specified")

    if process not in processes:
        raise ValueError("Invalid process \"%s\" specified; Valid processes: %s" % (str(process),str(processes)))

    process_phases = processes[process]
    
    original_script = basename+".py"

    if not nodircheck:
        if not os.path.exists(original_script):
            raise ValueError("original script \"%s\" not found (Do you need to run this script from the parent directory?" % (original_script))
        pass
    
    output_directory = output_dir(basename,nodircheck=nodircheck)
    basefile=os.path.split(basename)[1]
    
    #cad_file_name=os.path.join(output_directory,"%s_%s.sat" % (basefile,phase))
    script_to_generate=os.path.join(output_directory,"%s_%s_abq.py" % (basefile,phase))
    cad_file_path_from_script="%s_%s.step" % (basefile,phase)
    layer_boundary_template=os.path.join(output_directory,"%s_%s_bnd%%d_line%%d_ver%%d.stl" % (basefile,phase))

    return (script_to_generate,cad_file_path_from_script,layer_boundary_template)



def get_output_filenames_call(rb_tree,rb_tree_filename=None):
    """ Given a redbaron tree, return
    the node representing the call to "process.outputfilenames()"
    """
    
    output_filenames_nodematch=lambda node: (isinstance(node[0],redbaron.NameNode) and
                                             node[0].value=="process" and
                                             isinstance(node[1],redbaron.NameNode) and
                                             node[1].value=="output_filenames" and
                                             isinstance(node[2],redbaron.CallNode))
    
    output_filenames_calls = rb_tree.find_all("atomtrailers",output_filenames_nodematch)

    if len(output_filenames_calls) > 1:
        raise ValueError("More than one call to process.output_filenames() in file %s" % (str(rb_tree_filename)))

    if len(output_filenames_calls) == 0:
        raise ValueError("No call to process.output_filenames() in file %s" % (str(rb_tree_filename)))


    output_filenames_call=output_filenames_calls[0]
    return output_filenames_call


def get_process_phases(original_script_file_name):
    """ Given the path to an original script file,
    parse through the file to find all calls 
    to process.output_filenames()
    and determine the "process=" parameter, 
    returning the name of the process and the list of phases from the processes= 
    database (above). """


    if processor.original_to_predamage_tree is None:
        # i.e. if redbaron import failed
        
        return (None,processes[None])  # just ORIGINAL step
        
    
    original_tree=processor.tree_from_file(original_script_file_name)

    output_filenames_call = get_output_filenames_call(original_tree,original_script_file_name)
    


    paramvals,paramindexes = processor.extract_parameter_values(output_filenames_call,
                                                                output_filenames_params,
                                                                output_filenames_default_params)

    # Verify basename -- should match filename
    if isinstance(paramvals["basename"],redbaron.StringNode):
        basename=paramvals["basename"].to_python()

        (path,filename) = os.path.split(original_script_file_name)
        (script_basename,script_ext)=os.path.splitext(filename)

        if script_ext != ".py":
            raise ValueError("Script name %s has unexpected extension %s" % (filename,script_ext))

        if script_basename != basename:
            raise ValueError("basename \"%s\" from process.output_filenames() call in %s does not match filename" % (basename,original_script_file_name))        
        pass
    else:
        raise ValueError("basename parameter to process.output_filenames() call in %s is not a simple string" % (original_script_file_name))

    # verify phase... should be None or "ORIGINAL"

    phase_rb=paramvals["phase"]
    if isinstance(phase_rb,redbaron.NameNode) and phase_rb.value=="None":
        # Got None
        # ... OK
        pass
    elif isinstance(phase_rb,redbaron.StringNode):
        if phase_rb.to_python() != "ORIGINAL":
            raise ValueError("Base script %s should have call to output_filenames() with phase set to \"ORIGINAL\"")
        pass
    else:
        raise ValueError("Base script %s should have call to output_filenames() with phase set to \"ORIGINAL\"")

        pass
    
    
    # Get process
    process_rb = paramvals["process"]
    if isinstance(process_rb,redbaron.NameNode) and process_rb.value=="None":
        process = None
        pass
    elif isinstance(process_rb,redbaron.StringNode):
        process=process_rb.to_python()
        pass
    else:
        raise ValueError("output_filenames() process= parameter has uninterpretable value %s" % (process_rb.dumps()))

    
    if process not in processes:
        raise ValueError("Invalid process \"%s\" specified; Valid processes: %s" % (str(process),str(processes)))
                         
    # return process phases

    return (process,processes[process])


def update_phase(rb_tree,rb_tree_filename,newphase):
    """ Update the phase argument of the call to process.output_filenames()
    of a redbaron tree. The tree is updated in-place"""
    
    output_filenames_call = get_output_filenames_call(rb_tree,rb_tree_filename)

    paramsnode = output_filenames_call[-1]
    #output_filenames_params
    #output_filenames_default_params

    argnum=0
    phase_argument=None
    for argumentnode in paramsnode.value:
        assert(isinstance(argumentnode,redbaron.nodes.CallArgumentNode))
        if argumentnode.target is not None:
            # named parameter assignment
            if argumentnode.target.value=="phase":
                phase_argument=argumentnode
                pass
            pass
        elif argnum < len(output_filenames_params) and output_filenames_params[argnum]=="phase":
            phase_argument=argumentnode
            pass
        elif (argnum < len(output_filenames_params)+len(output_filenames_default_params) and
              list(output_filenames_default_params.keys())[argnum-len(output_filenames_params)]=="phase"):
            phase_argument=argumentnode
            pass
        pass
    if phase_argument is None:
        # parameter does not exist...
        # Need to add new one
        phase_argument=redbaron.CallArgumentNode.from_fst({"type":"call_argument",
                                                           "first_formatting": [],
                                                           "second_formatting": [],
                                                           "target": { "type": "name", "value": "phase" },
                                                           "value": { "type": "string", "value": "\"ORIGINAL\"",
                                                                      "first_formatting": [],
                                                                      "second_formatting": [],}
                                                           })
        paramsnode.value.append(phase_argument)
        pass

    # Got phase_argument which is mutable redbaron.CallArgumentNode
    # representing the phase parameter

    # update phase argument
    phase_argument.value = "\"%s\"" % (newphase)
    #return phase_argument

    pass

def generate_scriptname_for_phase(original_script_filename,phase):
    """ return a directory which may need to be created and the path 
    of the generation script for a  particular phase. Assumes 
    parameters already validated by get_process_phases()"""

    (path,filename) = os.path.split(original_script_filename)
    (script_basename,script_ext)=os.path.splitext(filename)

    if phase=="ORIGINAL" or phase is None:
        return (None,original_script_filename)

    output_directory = os.path.join(path,script_basename+"_output")


    scriptlocalname="%s_%s.py" % (script_basename,phase)
    scriptname = os.path.join(output_directory,scriptlocalname)

    return (output_directory,scriptname)

def output_filenames_for_phase(original_script_filename,phase,process_name):
    """ return output filenames for a particular phase of the specified
    process. Assumes parameters already validated by get_process_phases()"""

    (path,filename) = os.path.split(original_script_filename)
    (script_basename,script_ext)=os.path.splitext(filename)

    (script_to_generate,cad_file_path_from_script,layer_boundary_template) = output_filenames(script_basename,phase=phase,process=process_name,nodircheck=True)

    # note: script_to_generate is relative to the directory of the
    # original script,
    # cad_file_path_from_script is relative to the script_to_generate

    script_to_generate_path=os.path.join(path,script_to_generate)
    (output_dir,script_to_generate_name)=os.path.split(script_to_generate_path)
    cad_file_path=os.path.join(output_dir,cad_file_path_from_script)

    cad_file_name=cad_file_path_from_script

    return (output_dir,script_to_generate_path,cad_file_path,script_to_generate_name,cad_file_name)
    
def gen_status(original_script_name,phase_name,require_scripts):
    (output_directory,scriptname)=generate_scriptname_for_phase(original_script_name,phase_name)

    if os.path.exists(scriptname):
        mtime=os.path.getmtime(scriptname)
        return time.strftime("%Y/%m/%d %H:%M:%S",time.localtime(mtime))
    
    if not require_scripts:
        return "N/A"
    return "MISSING"

def buildmodel_status(original_script_name,phase_name,process_name,require_scripts):
    (output_dir,script_to_generate_path,cad_file_path,script_to_generate_name,cad_file_name)=output_filenames_for_phase(original_script_name,phase_name,process_name)

    #print(script_to_generate_path)
    #print(cad_file_path)
    if os.path.exists(script_to_generate_path) and os.path.exists(cad_file_path):
        mtime1=os.path.getmtime(script_to_generate_path)
        mtime2=os.path.getmtime(cad_file_path)

        # record earlier of times
        if mtime2 > mtime1:
            mtime=mtime1
            pass
        else:
            mtime=mtime2
            pass
        
        return time.strftime("%Y/%m/%d %H:%M:%S",time.localtime(mtime))

    if not require_scripts:
        return "N/A"
    
    return "MISSING"
