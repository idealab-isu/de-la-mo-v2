import sys
import os.path
from OCC.TopoDS import topods

from OCC.TopoDS import TopoDS_Face
from OCC.TopoDS import TopoDS_Shape
from OCC.TopoDS import TopoDS_Compound
from OCC.TopoDS import TopoDS_Wire
from OCC.TopoDS import TopoDS_Vertex
from OCC.TopoDS import TopoDS_Shell
from OCC.TopoDS import topods_Shell
from OCC.TopoDS import topods_Face
from OCC.TopoDS import topods_Edge
from OCC.BRep import BRep_Builder
from OCC.BRep import BRep_Tool
from OCC.BRepExtrema import BRepExtrema_DistShapeShape
from OCC import BRepLib
from OCC import BRepOffsetAPI
from OCC import BRepOffset
from OCC import BRepBuilderAPI
#from OCC.BRepClass import BRepClass_FacePassiveClassifier
from OCC.BRepClass import BRepClass_FaceExplorer
from OCC.BRepClass import BRepClass_FClassifier
from OCC.ShapeAnalysis import ShapeAnalysis_FreeBoundsProperties
from OCC.BRepTools import breptools_Read
from OCC.TopExp import TopExp_Explorer
from OCC.TopAbs import TopAbs_ON
from OCC.TopAbs import TopAbs_IN
from OCC.TopAbs import TopAbs_OUT
from OCC.TopAbs import TopAbs_FACE
from OCC.TopAbs import TopAbs_VERTEX
from OCC.TopAbs import TopAbs_EDGE
from OCC.TopAbs import TopAbs_SHELL
from OCC.TopAbs import TopAbs_FORWARD
from OCC.TopAbs import TopAbs_REVERSED
from OCC.GeomAbs import GeomAbs_Arc
from OCC.TopTools import TopTools_ListIteratorOfListOfShape
from OCC.GeomLProp import GeomLProp_SLProps
from OCC.gp import gp_Pnt2d
from OCC.gp import gp_Vec
from OCC.gp import gp_Dir
from OCC.gp import gp_Pnt
from OCC.GEOMAlgo import GEOMAlgo_Splitter
from OCC import GeomProjLib

from OCC.STEPControl import STEPControl_Reader
from OCC.STEPControl import STEPControl_Writer
from OCC.STEPControl import STEPControl_ManifoldSolidBrep
from OCC.STEPControl import STEPControl_Writer,STEPControl_ShellBasedSurfaceModel

from layer import LayerBody,LayerBodyFace

import loaders
import layer


class OCCModelBuilder(object):
    """The OCCModelBuilder contains global parameters 
    for constructing laminates using the OpenCascade geometry kernel plus various methods.
    
    When bonding layers: 
     * call OCCMB.applydelaminations(layer1,layer2,delamlist) for all layer pairs in the bonding step
       to perform the layer imprint and face region assignment operations. 
     * call FAL=OCCMB.adjacentlayers(layer1,layer2,"COHESIVE") to read out the face adjacency list. 
     * Once the FAL is read out, neither layer can have its layerbodies split (fiber breakage) because
       that would require changing the layerbody names stored in the FAL. 
     * Thus any layer splitting must occur prior to the first adjacentlayers() call for that layer. 
     * Layer (body) splitting would also require an imprint operation on any adjoining layers. 
    """

    # Class members
    PointTolerance = None # Point positioning tolerance in mm
    NormalTolerance = None # Tolerance used for normal vectors
    Debug = None  # Flag for enabling troubleshooting output
    NextUnique = None # Next number to be generated by the Unique() method
    GapWidth = None # size of NOMODEL gap
    
    # Constructor
    def __init__(self,**kwargs):
        # Default values:
        self.PointTolerance=1e-5
        self.NormalTolerance=1e-6
        self.Debug=False
        self.NextUnique=0
        
        for argname in kwargs:
            if not hasattr(self,argname):
                raise ValueError("Invalid attribute")
            setattr(self,argname,kwargs[argname])
            pass
        pass
    
    
    # Class methods
    def Unique(self):
        """Return a unique number (increasing sequence starting at 0)"""
        
        UniqueVal=self.NextUnique
        self.NextUnique += 1
        return UniqueVal
    

    def eval_face_pairs(self,layerbody1,layerbody2):
        """Evaluate the face pairs common between layerbody1 and layerbody2.
        Return a dictionary indexed by the common faces from layerbody1 that 
        identifies the corresponding faces from layerbody2"""

        FaceListTotal1 = layerbody1.FaceListOrig + layerbody1.FaceListOffset + layerbody1.FaceListSide
        FaceListTotal2 = layerbody2.FaceListOrig + layerbody2.FaceListOffset + layerbody2.FaceListSide
        
        CommonFaces = {}
        for face1 in FaceListTotal1:
            if face1 in FaceListTotal2:
                face2=FaceListTotal2[FaceListTotal2.index(face1)]

                # Note that face1 and face2 pass equality (== operator) because
                # equality operator identifices equivalent geometry. But the face1 and
                # face2 objects are actually different!
                
                CommonFaces[face1]=face2
                pass
            pass

        return CommonFaces

    def process_delamination(self,layerbody1,layerbodyface1,layerbody2,layerbodyface2,delam_outline):
        """Given a first layerbody and corresponding face, and a second 
        layerbody and corresponding face, and a delamination outline 
        (loop of 3D coordinates, hopefully projected onto the faces): 
           1. Identify the regions of facebody1/2 that are inside delam_outline
           2. Create an offset curve a distance of self.GapWidth inside delam_outline
           3. Imprint both delam_outline and the offset curve
           4. Identify the regions of facebody1/2 that are between delam_outline and the offset
              curve to have "NOMODEL" BCType unless they already had "CONTACT" BCType 
           5. Identify the regions of facebody1/2 that are inside the offset curve to have "CONTACT"
              BCType
           6. Generate new replacements for layerbody1 and layerbody2 with newly constructed
              imprinted faces, marked as determined above. 
           7. The replaced layerbody1 and layerbody2 may have facebody1 and facebody2 
              replaced/subdivided, but other faces in layerbodies1/2 should remain unchanged. 
           8. Return (replacement_layerbody1, replacement_layerbody2)"""

        # NOTE: May need additional parameters (adjacent surfaces or faces?) to do the
        # delam_outline offset curve?

        # NOTE: When regenerating layerbodies, do NOT give them new names unless they are being
        # split (which they aren't from this function)

        # ***!!! Temporarily load curve rather than constructing wire from delamination outline
        WireShape = loaders.load_byfilename(os.path.join("..","data","Delam1.STEP"))

        exp=TopExp_Explorer(WireShape,TopAbs_EDGE)
        
        # Iterate over all edges
        edge_shapes=[]
        while exp.More():
            edge_shapes.append(exp.Current())
            
            exp.Next()
            pass

        edge_edges = [ topods_Edge(edge_shape) for edge_shape in edge_shapes ]

        edge_curves = [ BRep_Tool.Curve(edge) for edge in edge_edges ]


        # layerbodyface1

        layerbodysurface1 = BRep_Tool.Surface(layerbodyface1.Face)

        # Note: edge_curves[i][1] and edge_curves[i][2] appear to be start and end u coordinates for curve
        Projections = [ GeomProjLib.geomprojlib_Project(edge_curve[0],layerbodysurface1) for edge_curve in edge_curves ]

        # Right here we should be trimming our projection to line up with layerbodyface1 and the unprojected edge (element of edge_edges)
        # But it's probably OK not to, because we are using the projection to make a tool that will be used to cut the face
        # and the extension of the tool beyond the face boundary shouldn't cause any problems, at least so long as thath
        # geometry doesn't get too weird
        
        ProjectionEdges = [ BRepBuilderAPI.BRepBuilderAPI_MakeEdge(Projection).Edge() for Projection in Projections ]

        # If we did trimmming, we would need to construct wire from the edge(s) that actually projected to something within the face,
        # with any gaps filled by appropriately trimmed edges from the face.

        #ProjectedWireBuilder = BRepBuilderAPI.BRepBuilderAPI_MakeWire()
        #
        #for ProjectionEdge in ProjectionEdges:
        #    ProjectedWireBuilder.add(ProjectionEdge)
        #    pass
        #
        # ProjectedWire = ProjectedWireBuilder.Wire()


        # Generate faces connecting original and projected edges.
        # We will use this as a tool to do the cut. 

        # For the moment assume only one edge
        
        build=BRep_Builder()
        #Perimeter=TopoDS_Compound()
        #build.MakeCompound(Perimeter)
        
        origwire = TopoDS_Wire()
        build.MakeWire(origwire)
        projwire = TopoDS_Wire()
        build.MakeWire(projwire)
        
        for edgecnt in range(len(edge_edges)):
            edge=edge_edges[edgecnt]
            projectionedge = ProjectionEdges[edgecnt]
            
            
            build.Add(origwire,edge)
            build.Add(projwire,projectionedge)
            pass

        # Generate side faces
        SideGenerator = BRepOffsetAPI.BRepOffsetAPI_ThruSections()
        SideGenerator.AddWire(origwire)
        SideGenerator.AddWire(projwire)
        SideGenerator.Build()
        
        if (not SideGenerator.IsDone()):
            raise ValueError("Side face generation failed\n")
        
        SideShape = SideGenerator.Shape()
        
        #build.Add(Perimeter,SideShape)
        
        step_writer2=STEPControl_Writer()
        step_writer2.Transfer(SideShape,STEPControl_ShellBasedSurfaceModel,True)
        step_writer2.Write("../data/outersurf.STEP")

        GASplitter=GEOMAlgo_Splitter()
        GASplitter.AddArgument(layerbodyface1.Face)
        GASplitter.AddTool(SideShape)
        GASplitter.Perform()
        SplitFace= GASplitter.Shape()
        # Hopefully this did not damage layerbodyface1
        
        step_writer3=STEPControl_Writer()
        step_writer3.Transfer(SplitFace,STEPControl_ShellBasedSurfaceModel,True)
        step_writer3.Write("../data/splitted.STEP")

        split_face_exp=TopExp_Explorer(SplitFace,TopAbs_FACE)
        # Iterate over all faces
        numsplitfaces = 0
        split_face_shapes=[]
        while split_face_exp.More():
            split_face_shapes.append(split_face_exp.Current())
            numsplitfaces = numsplitfaces +1

            split_face_exp.Next()
            pass

        print("Number of split faces %d"%(numsplitfaces))

        # split_face_shapes now should have two or more faces (TopoDS_Shape of type Face
        # Need to create a new layerbody with the original layerbodyfaces except for this one, and two new layerbodyfaces


        # Create a new layerbody with the split face
        DelamLayerBody1 = LayerBody()
        DelamLayerBody1.Name = layerbody1.Name
        DelamLayerBody1.Owner = layerbody1.Owner

        sys.modules["__main__"].__dict__.update(globals())
        sys.modules["__main__"].__dict__.update(locals())
        raise ValueError("Break")


        # Now we have to sew all of these pieces together
        # (with a thread!)
        thread = BRepBuilderAPI.BRepBuilderAPI_Sewing()  # sewing tool
        # Add the other faces of the layerbody1
        for layerbodyface in layerbody1.FaceListOrig:
            if (layerbodyface != layerbodyface1):
                DelamLayerBody1.FaceListOrig.append(layerbodyface)
                thread.Add(layerbodyface.Face)
            else:
                for split_face in split_face_shapes:
                    DelamLayerBody1.FaceListOrig.append(LayerBodyFace.FromOCC(split_face,"ORIG",Owner=DelamLayerBody1))
                    thread.Add(split_face)
                    pass
            pass

        for layerbodyface in layerbody1.FaceListOffset:
            if (layerbodyface != layerbodyface1):
                DelamLayerBody1.FaceListOffset.append(layerbodyface)
                thread.Add(layerbodyface.Face)
            else:
                for split_face in split_face_shapes:
                    #DelamLayerBody1.FaceListOffset.append(LayerBodyFace.FromOCC(split_face,"OFFSET",Owner=DelamLayerBody1))
                    thread.Add(split_face)
                    pass
            pass

        for layerbodyface in layerbody1.FaceListSide:
            DelamLayerBody1.FaceListSide.append(layerbodyface)
            pass

        thread.Perform()
        sewedShell = thread.SewedShape()

        # if it is a closed shell, turn it into a solid if possible
        if sewedShell.ShapeType() != TopAbs_SHELL or not sewedShell.Closed():
            raise ValueError("Resulting solid either not a shell or not closed")

        # SolidMaker = BRepBuilderAPI.BRepBuilderAPI_MakeSolid(TopoDS.Shell(ResultShape))
        solidMaker = BRepBuilderAPI.BRepBuilderAPI_MakeSolid()
        solidMaker.Add(topods_Shell(sewedShell))
        if not solidMaker.IsDone():
            raise ValueError("Solid maker failed")

        delamSolidShape = solidMaker.Solid()

        if not BRepLib.breplib_OrientClosedSolid(delamSolidShape):
            raise ValueError("Solid maker did not yield a closed solid")
        # We successfully got a closed solid

        DelamLayerBody1.Shape = delamSolidShape

        step_writer = STEPControl_Writer()
        step_writer.Transfer(delamSolidShape, STEPControl_ManifoldSolidBrep, True)
        step_writer.Write("../Data/Layers.step")

        # Also need to repeat the process for the other face

        # (so actual content of this function should be abstracted into
        # a new function we can call twice). 

        
        raise NotImplementedError()

    def apply_delaminations(self,layer1,layer2,delaminationlist):
        """Iterate over the layerbodies of layer1 and layer2. For each pair of layerbodies, 
        evaluate the common faces with eval_face_pairs(). For each common face pair and 
        each delamination, update the corresponding layerbodies with process_delamination. 
        
        When done, rerun eval_face_pairs and use the resulting dictionary to construct and 
        return a face adjacency list (FAL)"""

        for lb1cnt in range(len(layer1.BodyList)):
            lb1=layer1.BodyList[lb1cnt]

            for lb2cnt in range(len(layer2.BodyList)):
                lb2=layer2.BodyList[lb2cnt]
                
                CommonFaces=self.eval_face_pairs(lb1,lb2)

                for CommonFace in CommonFaces:
                    for delamination in delaminationlist:
                        (replacement_lb1,replacement_lb2)=self.process_delamination(lb1,CommonFace,lb2,CommonFaces[CommonFace],delamination)
                        layer1.BodyList[lb1cnt]=replacement_lb1
                        layer2.BodyList[lb2cnt]=replacement_lb2
                        pass
                    pass

                pass
            pass
        pass
    
    def adjacent_layers(self,layer1,layer2,defaultbc,bc_map=None):
        """ Once adjacent_layers() is called, the LayerBody's in EITHER layer can't be split
        anymore -- because then they might need new names,
        and the return values contain the layer body names that will be used
        to apply the boundary conditions"""
        
        FAL = [] # Face Adjacency List
        
        for lb1 in layer1.BodyList:
            for lb2 in layer2.BodyList:
                FacePairs=self.eval_face_pairs(lb1,lb2)
                for postimprint_CommonFace in FacePairs:
                    BCType=postimprint_CommonFace.BCType

                    assert(lb1.Name is not None)
                    assert(lb2.Name is not None)
                    
                    if BCType is None: # BCType not otherwise set... insert default
                        BCType=defaultbc
                        pass
                    elif bc_map is not None:
                        # apply user-supplied BC mapping
                        BCType=bc_map[BCType]
                        pass
                    FAL.append( { "name1": lb1.Name,
                                  "name2": lb2.Name,
                                  "bcType": BCType,
                                  "point1": postimprint_CommonFace.Point,
                                  "normal1": postimprint_CommonFace.Normal,
                                  #"point2": FacePairs[postimprint_CommonFace].Point,
                                  #"normal2": FacePairs[postimprint_CommonFace].Normal,
                    })
                    pass
                
                pass
            
            pass
        
        return FAL


    def save(self,cad_file_name,to_be_saved):
        step_writer=STEPControl_Writer()
        BodyNameList=[]
        BodyNameSet=set([])

        #for layerobj in to_be_saved:
        #    for layerbodyobj in layerobj.BodyList:
                
        for layerbodyobj in to_be_saved:
            step_writer.Transfer(layerbodyobj.Shape,STEPControl_ManifoldSolidBrep,True)
            
            assert(not(layerbodyobj.Name in BodyNameSet)) # verify nome layerbodyname reuse!
            
            BodyNameList.append(layerbodyobj.Name)
            
            BodyNameSet.add(layerbodyobj.Name)
            
            pass
        
        step_writer.Write(cad_file_name)
        
        
        return BodyNameList
    
    pass


if __name__=="__main__":
    MB=OCCModelBuilder(PointTolerance=1e-5,NormalTolerance=1e-6)
    
    Mold = layer.LayerMold.FromFile(os.path.join("..","data","CurvedMold1.STEP"))
    Layer1=layer.Layer.CreateFromMold("Layer 1",Mold,2.0,"OFFSET",1e-6)
    Layer2=layer.Layer.CreateFromMold("Layer 2",Layer1.OffsetMold(),2.0,"OFFSET",1e-6)

    #delaminationlist = [ ]
    delaminationlist = [ os.path.join("..","data","nasa-delam-12-1.csv") ]

    #defaultBCType = 2
    #FAL = MB.adjacent_layers(Layer1,Layer2,defaultBCType)
    MB.apply_delaminations(Layer1,Layer2,delaminationlist)


    step_writer=STEPControl_Writer()
    
    step_writer.Transfer(Layer1.BodyList[0].Shape,STEPControl_ManifoldSolidBrep,True)
    step_writer.Transfer(Layer2.BodyList[0].Shape,STEPControl_ManifoldSolidBrep,True)
    step_writer.Write(os.path.join("..","Data","Layers.step"))

    pass
